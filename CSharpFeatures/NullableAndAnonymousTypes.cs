using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSharpFeatures
{
    //Nullable types are instances of the System.Nullable<T> struct. A nullable type can represent the correct range of values for its underlying value type, plus an additional null value
    //Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first. The type name is generated by the compiler and is not available at the source code level. The type of each property is inferred by the compiler.
    class NullableAndAnonymousTypes
    {
        public void Execute()
        {
            //Nullable types
            int i1 = 10;
            int? i2 = null;
            if (!i2.HasValue) i2 = 20;
            Console.WriteLine(i1+i2);

            //Use the ?? operator to assign a default value that will be applied when a nullable type whose current value is null is assigned to a non-nullable type, for example int? x = null; int y = x ?? -1;
            int? x = null; 
            int y = x?? -1;
            Console.WriteLine(y);

            //Anonymous types
            //Anonymous types are class types that derive directly from object, and that cannot be cast to any type except object. The compiler provides a name for each anonymous type, although your application cannot access it. From the perspective of the common language runtime, an anonymous type is no different from any other reference type.
            var v = new { Amount = 108, Message = "Hello" };//// Compiler infers from statement to verify that their types are int and string
            Console.WriteLine(v.Amount + v.Message);
            //You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type. Similarly, you cannot declare a formal 
            //parameter of a method, property, constructor, or indexer as having an anonymous type. To pass an anonymous type, or a collection that contains 
            //anonymous types, as an argument to a method, you can declare the parameter as type object. However, doing this defeats the purpose of strong typing. 
            //If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.

            //Anonymous array
            var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 } };

            //Implicit Typing
            //Implicitly typed are types that are impicitly converted to the type at compile time

            // i is compiled as an int 
            //var i = 5;

            // s is compiled as a string 
            //var s = "Hello";

            // a is compiled as int[] 
            //var a = new[] { 0, 1, 2 };

            //In many cases the use of var is optional and is just a syntactic convenience. However, when a variable is initialized with 
            //an anonymous type you must declare the variable as var if you need to access the properties of the object at a later point. 
            //Also, the use of anonymous types can hide good opportunities to improve your design
        }

    }
}
